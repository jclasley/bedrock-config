* Bedrock stuff
#+begin_src elisp
    (when (< emacs-major-version 29)
      (error (format "Emacs Bedrock only works with Emacs 29 and newer; you have version ~a" emacs-major-version)))
    (setopt initial-major-mode 'fundamental-mode)  ; default mode for the *scratch* buffer
    (setopt display-time-default-load-average nil) ; this information is useless for most

    (setopt auto-revert-avoid-polling t)
    (setopt auto-revert-interval 5)
    (setopt auto-revert-check-vc-info t)
    (global-auto-revert-mode)

    ;; Save history of minibuffer
    (savehist-mode)

    ;; Fix archaic defaults
    (setopt sentence-end-double-space nil)

    ;; Make right-click do something sensible
    (when (display-graphic-p)
      (context-menu-mode))

    ;; Don't litter file system with *~ backup files; put them all inside
    ;; ~/.emacs.d/backup or wherever
    (defun bedrock--backup-file-name (fpath)
      "Return a new file path of a given file path.
    If the new path's directories does not exist, create them."
      (let* ((backupRootDir "~/.emacs.d/emacs-backup/")
             (filePath (replace-regexp-in-string "[A-Za-z]:" "" fpath )) ; remove Windows driver letter in path
             (backupFilePath (replace-regexp-in-string "//" "/" (concat backupRootDir filePath "~"))))
        (make-directory (file-name-directory backupFilePath) (file-name-directory backupFilePath))
        backupFilePath))
    (setopt make-backup-file-name-function 'bedrock--backup-file-name)

    ;; which-key: shows a popup of available keybindings when typing a long key
    ;; sequence (e.g. C-x ...)
    (use-package which-key
      :config
      (setq which-key-keymap-history t)
      (which-key-enable-god-mode-support)
      (which-key-mode))


  (setopt completion-auto-select 'second-tab)            ; Much more eager

    (keymap-set minibuffer-mode-map "TAB" 'minibuffer-complete) ; TAB acts more like how it does in the shell

    ;; Mode line information
    (setopt line-number-mode t)                        ; Show current line in modeline
    (setopt column-number-mode t)                      ; Show column as well

    (setopt x-underline-at-descent-line nil)           ; Prettier underlines
    (setopt switch-to-buffer-obey-display-actions t)   ; Make switching buffers more consistent

    (setopt show-trailing-whitespace nil)      ; By default, don't underline trailing spaces
    (setopt indicate-buffer-boundaries 'left)  ; Show buffer top and bottom in the margin

    ;; Enable horizontal scrolling
    (setopt mouse-wheel-tilt-scroll t)
    (setopt mouse-wheel-flip-direction t)

    ;; We won't set these, but they're good to know about
    ;;
    ;; (setopt indent-tabs-mode nil)
    ;; (setopt tab-width 4)

    ;; Misc. UI tweaks
    (blink-cursor-mode -1)                                ; Steady cursor
    (pixel-scroll-precision-mode)                         ; Smooth scrolling

    ;; Display line numbers in programming mode
    (add-hook 'prog-mode-hook 'display-line-numbers-mode)
    (setopt display-line-numbers-width 3)           ; Set a minimum width

    ;; Nice line wrapping when working with text
    (add-hook 'text-mode-hook 'visual-line-mode)

    ;; Modes to highlight the current line with
    (let ((hl-line-hooks '(text-mode-hook prog-mode-hook)))
      (mapc (lambda (hook) (add-hook hook 'hl-line-mode)) hl-line-hooks))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;;
    ;;;   Tab-bar configuration
    ;;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;; Show the tab-bar as soon as tab-bar functions are invoked
    (setopt tab-bar-show 1)

    ;; Add the time to the tab-bar, if visible

    (custom-set-variables
     ;; custom-set-variables was added by Custom.
     ;; If you edit it by hand, you could mess it up, so be careful.
     ;; Your init file should contain only one such instance.
     ;; If there is more than one, they won't work right.
     '(package-selected-packages
       '(dracula-theme company use-package use-package-chords key-chord evil which-key)))
    (custom-set-faces
     ;; custom-set-faces was added by Custom.
     ;; If you edit it by hand, you could mess it up, so be careful.
     ;; Your init file should contain only one such instance.
     ;; If there is more than one, they won't work right.
     )

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;;; My stuff
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#+end_src

#+RESULTS:

* My emacs stuff
Turn off the damn bell
#+begin_src elisp
  (setq ring-bell-function nil)
#+end_src

* Keymaps
Make some keymaps for nice viewing
Convenience function for making outer and inner keymaps
#+begin_src elisp
  (defmacro new-keymap (name binding)
    `(progn
       (setq ,(concat "my/" name "-map") (make-sparse-keymap))
       (define-key global-map
                   (kbd ,(concat "C-c " binding))
                   (list (,name . ,(make-symbol (concat "my/" name "-map")))))))
#+end_src


** Consult
#+begin_src elisp
  (setq my/consult-map (make-sparse-keymap))
  (define-key global-map (kbd "C-c s") `("consult" . ,my/consult-map))
  #+end_src

  
** Goto
For things like =goto-line= or =goto-word=
#+begin_src elisp
(setq my/goto-map (make-sparse-keymap))
  (define-key global-map (kbd "C-c l") `("goto" . ,my/goto-map))
#+end_src

** Windows
Window management
#+begin_src elisp
  (setq my/window-map (make-sparse-keymap))
  (define-key global-map (kbd "C-c w") `("windows" . ,my/window-map))
#+end_src


* General packages
Sticky scroll! My own package ðŸ¥²
#+begin_src elisp
  ;; (use-package sticky-scroll-mode
  ;;   :ensure t
  ;;   :hook
  ;;   (prog-mode . sticky-scroll-mode))
#+end_src


Show indentation lines
#+begin_src elisp
  (use-package highlight-indent-guides
    :ensure t
    :hook
    (prog-mode . highlight-indent-guides-mode)
    (yaml-mode . highlight-indent-guides-mode)
    :config
    (setq highlight-indent-guides-method 'bitmap
          highlight-indent-guides-auto-enabled nil)
    (set-face-background 'highlight-indent-guides-odd-face "gray45")
    (set-face-background 'highlight-indent-guides-even-face "gray45")
    (set-face-foreground 'highlight-indent-guides-character-face "gray45"))
#+end_src


Bring this in for use later
#+begin_src elisp
  (use-package dash :ensure t)
#+end_src

Search
#+begin_src elisp
  (use-package ag :ensure t)
#+end_src

Icons
#+begin_src elisp
    (use-package all-the-icons
      :ensure t)
#+end_src

Lightning fast scrolling!
[[https://github.com/jdtsmith/ultra-scroll][Ref]]
#+begin_src elisp
  (use-package ultra-scroll
  ;:load-path "~/code/emacs/ultra-scroll" ; if you git clone'd instead of package-vc-install
    :vc (:url "https://github.com/jdtsmith/ultra-scroll")
    :init
    (setq scroll-conservatively 101 ; important!
  	scroll-margin 0) 
    :config
    (ultra-scroll-mode 1))
#+end_src


#+begin_src elisp
  (winner-mode 1)
  (recentf-mode 1)

  (eldoc-mode 1)
#+end_src

#+begin_src elisp

    ;; get use-package to behave
    (setq package-archives
          '(("melpa" . "https://melpa.org/packages/")
            ("org" . "https://orgmode.org/elpa/")
            ("elpa" . "https://elpa.gnu.org/packages/")
  	  ("nongnu" . "https://elpa.nongnu.org/nongnu/")))

    (use-package use-package-chords
      :ensure t
      :config (key-chord-mode 1))
#+end_src

#+RESULTS:
: t

rainbow delimiters
#+begin_src elisp
  (use-package rainbow-delimiters 
    :ensure t
    :config (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+end_src

Highlight todos in prog mode derivatives
#+begin_src elisp
  (use-package hl-todo
    :ensure t
    :hook (prog-mode . hl-todo-mode)
    :config
    (setq hl-todo-highlight-punctuation ":"
          hl-todo-keyword-faces
          `(("TODO"       warning bold)
            ("FIXME"      error bold)
            ("HACK"       font-lock-constant-face bold)
            ("REVIEW"     font-lock-keyword-face bold)
            ("NOTE"       success bold)
            ("DEPRECATED" font-lock-doc-face bold))))
#+end_src

** Source in scripts
Load the larger form customizations segregated by their own files
#+begin_src elisp
  (let ((dir (expand-file-name "~/emacs/scripts")))
  (dolist (f (directory-files dir t ".el"))
	    (load-file f)))
#+end_src

#+RESULTS:


** Appearance
*** Theme

Doom themes
#+begin_src elisp
  (use-package doom-themes
  :ensure t
  :custom
  (doom-themes-enable-bold t)
  (doom-themes-enable-italic t)
  :config
  (load-theme 'doom-dracula t)

  ;; Enable flashing mode-line on errors
  (doom-themes-visual-bell-config)
  ;; or for treemacs users
  ;; Corrects (and improves) org-mode's native fontification.
  (doom-themes-org-config))
#+end_src
**** Dracula
#+begin_src elisp
  (use-package dracula-theme
    :ensure t
    :disabled t
    :init
    (load-theme 'dracula t))
#+end_src

**** Modus themes
Can try and mess around with these if I want
#+begin_src elisp
  (use-package modus-themes
    :ensure t
#+end_src

Disable it!
#+begin_src elisp
  ;; :disabled t
#+end_src


***** Customization
#+begin_src elisp
  :custom
#+end_src


Reload the theme after we change some of the options
#+begin_src elisp
  (modus-themes-custom-auto-reload t)
#+end_src


Reference for custom options: https://protesilaos.com/emacs/modus-themes#h:9001527a-4e2c-43e0-98e8-3ef72d770639

Use more bold (keywords) and italic constructs
#+begin_src elisp
  (modus-themes-bold-constructs t)
  (modus-themes-italic-constructs t)
#+end_src

Try out this example and see what it looks like -- might work
Affects the completion framework
#+begin_src elisp
  (modus-themes-completions
      '((matches . (extrabold underline))))
#+end_src

More advanced customizations
https://protesilaos.com/emacs/modus-themes#h:f4651d55-8c07-46aa-b52b-bed1e53463bb

More intense themes
#+begin_src elisp
  :config
  ;; dracula inspired colore scheme
  (setq modus-themes-common-palette-overrides
      '((type "#FF79C6")
      (builtin "#FF79C6")
      (constant "#F1FA8C")
      (variable "#8BE9FD")
      (keyword "#50FA7B")
      (string "#FFB86C")
      (rx-construct "#39b859")
      (rx-backslash "#ba7a36")
      (property "#acfadc")
      (comment "#6272A4")
      (preprocessor red)
      (fnname "#BD93F9"))) 
      ;; (setq modus-themes-common-palette-overrides
      ;;     `(
      ;;       ;; From the section "Make the mode line borderless"
      ;;       (border-mode-line-active unspecified)
      ;;       (border-mode-line-inactive unspecified)

      ;;       ;; From the section "Make matching parenthesis more or less intense"
      ;;       (bg-paren-match bg-magenta-intense)
      ;;       (underline-paren-match fg-main)

      ;;       ;; And expand the preset here.  Note that the ,@ works because
      ;;       ;; we use the backtick for this list, instead of a straight
      ;;       ;; quote.
      ;;       ,@modus-themes-preset-overrides-intense))
      ;;       ;; ))
#+end_src

End the customization and load the theme
#+begin_src elisp
      
  ;;  (load-theme 'modus-vivendi-tinted :no-confirm)
  )
#+end_src


**** ef themes

Also by prot, these are little sexier
https://protesilaos.com/emacs/ef-themes

#+begin_src elisp
  (use-package ef-themes
    :ensure t
    :disabled t
    :config
    ;; disable other themes
    (mapc #'disable-theme custom-enabled-themes)
    (load-theme 'ef-owl t))
#+end_src

#+RESULTS:

*** popper
#+begin_src elisp
  (use-package popper
    :ensure t ; or :straight t
    :bind (("C-`"   . popper-toggle)
           ("s-."   . popper-cycle)
           ("C-M-`" . popper-toggle-type)
           ("C-<escape>" . popper-kill-latest-popup))
    :init
    (setq popper-reference-buffers
          '("\\*Messages\\*"
            "Output\\*$"
            "\\*Async Shell Command\\*"
            help-mode
            compilation-mode))
    (popper-mode +1)
    (popper-echo-mode +1))   
#+end_src

#+RESULTS:
: popper-kill-latest-popup

*** solaire mode
Darkens non-file-associated buffers
[[https://github.com/hlissner/emacs-solaire-mode][Reference]]
#+begin_src elisp
  (use-package solaire-mode
    :ensure t
    :init
    (solaire-global-mode +1))
#+end_src

#+RESULTS:


** Modeline
#+begin_src elisp
  (use-package nerd-icons
    :ensure t)
#+end_src

#+begin_src elisp
  (use-package doom-modeline
    :ensure t
    :config
    (setq doom-modeline-minor-modes nil)
    :hook
    (lsp-mode . (lambda () (setq-local doom-modeline-buffer-name nil)))
    :init (doom-modeline-mode 1))
#+end_src

#+RESULTS:
| #[nil ((setq-local doom-modeline-buffer-name nil)) nil] | dap-tooltip-update-mouse-motions-if-enabled |

*** Spaceline
https://github.com/TheBB/spaceline?tab=readme-ov-file#introduction
#+begin_src elisp
  (use-package spaceline
    :ensure t)  
#+end_src

Use a nice lil icon one for it
https://github.com/domtronn/spaceline-all-the-icons.el
#+begin_src elisp
  (use-package spaceline-all-the-icons
    :ensure t
    :disabled t
    :after spaceline all-the-icons
    :requires all-the-icons
    :config (if (display-graphic-p) (spaceline-all-the-icons-theme)))
#+end_src


** Midnight mode
Runs at midnight every day
#+begin_src elisp

    (midnight-mode 1)
    ;; number of days before a buffer is eligible for killing
    (setq clean-buffer-list-delay-general 1)
    (add-to-list 'clean-buffer-list-kill-regexps
                 (rx buffer-start "magit-" (or "process" "diff")))
#+end_src


** Emacs customization
Make a keymap for =project.el= 
#+begin_src elisp
  (setq my/project-map (make-sparse-keymap))
  (define-key global-map (kbd "C-c p") `("project" . ,my/project-map))
#+end_src

#+RESULTS:
| project | keymap |

Function to kill backwards to the first character
#+begin_src elisp
  (defun backward-kill-line ()
    (interactive)
    (set-mark-command nil)
    (back-to-indentation)
    (kill-region (region-beginning) (region-end)))
#+end_src

#+begin_src elisp
  (use-package emacs
    :custom
    (tab-always-indent 'complete)
    ;; Emacs 28 and newer: Hide commands in M-x which do not apply to the current
    ;; mode.  Corfu commands are hidden, since they are not used via M-x. This
    ;; setting is useful beyond Corfu.
    (read-extended-command-predicate #'command-completion-default-include-p)
    (enable-recursive-minibuffers t)
    ;; more comfort
    (line-spacing 3)
    (scroll-conservatively 101)
    ;; use a very narrow window divider
    (window-divider-default-right-width 1)
    (window-divider-default-bottom-width 1)
    (scroll-bar-mode nil)
    (xref-prompt-for-identifier nil)
    (desktop-save-mode t)
    (cursor-style 'bar)
    ;; don't show cursors in non-active windows
    (cursor-in-non-selected-windows nil)
    :config 
    (electric-pair-mode 1)    
    (menu-bar-mode -1) ;; It doesn't help me at all
    ;; wrap on whitespace
    (global-word-wrap-whitespace-mode 1)
    (auto-save-mode -1) ; turn off autosave
    (setq auto-save-timeout 3)
    (setq ediff-window-setup-function #'ediff-setup-windows-plain)
    (menu-bar-bottom-and-right-window-divider)
    (scroll-bar-mode -1)
    ;; font installed from https://www.jetbrains.com/lp/mono/
    (add-to-list 'default-frame-alist '(font . "DroidSansM Nerd Font"))
    :bind
    ("C-<return>" . recenter)
    ("M-<backspace>" . backward-kill-word)
    ("C-M-RET" . xref-find-references)
    ("s-K" . kill-buffer-and-window)
    ("C-M-." . xref-find-definitions-other-window)
    ("C-q" . bury-buffer)
    ("s-<backspace>" . backward-kill-line)
  ("C-M-z" . zap-up-to-char)
  :init
    (defun crm-indicator (args)
      (cons (format "[CRM%s] %s"
              (replace-regexp-in-string
               "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
               crm-separator)
              (car args))
      (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator))
#+end_src

#+RESULTS:
: zap-up-to-char

#+begin_src elisp
  (use-package kmacro
    :config
    (defalias 'kmacro-insert-macro 'insert-kbd-macro)
    (define-key kmacro-keymap (kbd "I") #'kmacro-insert-macro))
#+end_src

*** Markdown
Use =glow= as the markdown viewer
https://github.com/charmbracelet/glow
#+begin_src elisp
  (setq markdown-command "glow")
#+end_src


*** tty mode
=kkp.el= provides support for common escape sequences and reading of the super key (hopefully)
#+begin_src elisp
  (use-package kkp
    :ensure t
    :config
    (global-kkp-mode 1))
#+end_src

Specific settings that we only want when in TTY
#+begin_src elisp
        (unless (display-graphic-p)
          (menu-bar-mode -1))
#+end_src

** Project management

*** Projectile
Projectile segregates a lot of things based on the project we're in
#+begin_src elisp
  (use-package projectile
    :ensure t
    :disabled
    :config
    ;; open up a scratch buffer for the project
    (setq projectile-switch-project-action 'projectile-dired)
    :bind
    (("C-c p" . #'projectile-command-map))
    :init (projectile-mode +1))
#+end_src

*** Persp

**** Perspective

Perspective mode separates buffers and allows for quick switching
[[https://github.com/nex3/perspective-el][reference]]
#+begin_src elisp
  (use-package perspective
    :disabled
    :ensure t
    :bind
    (("C-x C-b" . persp-list-buffers)
     :map persp-mode-map
     ("C-c C-p '" . persp-switch-last)
     ("C-c C-p C-s" . persp-switch)
     ("C-c C-p N" . my/new-persp)) ; or use a nicer switcher, see below
    :custom
    (persp-mode-prefix-key (kbd "C-c C-p"))  ; pick your own prefix key here
    :init
    (persp-mode))
#+end_src



Custom function for creating an empty perspective
#+begin_src elisp
  ;; (defun my/new-persp (name)
  ;;   (interactive "SName: ")
  ;;   (persp-new name))
#+end_src

**** persp-mode

A fork of perspective
[[https://github.com/Bad-ptr/persp-mode.el][Reference]]
#+begin_src elisp
  (use-package persp-mode
    :ensure t
    :disabled
    :bind
    (("C-x C-b" . persp-list-buffers)
     :map persp-mode-map
     ("C-c C-p '" . persp-switch-last)
     ("C-c C-p C-s" . persp-switch)
     ("C-c C-p N" . my/new-persp)) ; or use a nicer switcher, see below
    :custom
    (persp-mode-prefix-key (kbd "C-c C-p"))  ; pick your own prefix key here
    :init
    (persp-mode))
#+end_src



*** Persp-projectile
Integrate persp and projectile
#+begin_src elisp
  (use-package persp-projectile
    :disabled
    :ensure t
    :bind
    (("C-c p p" . projectile-persp-switch-project)))
#+end_src

** Origami -- nice folding
#+begin_src elisp
  (use-package origami
    :ensure t
    :bind
    (("C-c C-z z" . origami-forward-toggle-node)
     ("C-c C-z C" . origami-close-all-nodes)
     ("C-c C-z O" . origami-open-all-nodes)
     ("C-c C-z b" . origami-previous-fold)
     ("C-c C-z n" . origami-next-fold))
    :init (global-origami-mode))
#+end_src

#+RESULTS:
: origami-next-fold

** Icons
#+begin_src elisp
  (use-package all-the-icons
    :if (display-graphic-p))

  (use-package nerd-icons
    :if (display-graphic-p))
#+end_src

#+RESULTS:


** Tabs
[[https://github.com/ema2159/centaur-tabs][Reference]]
#+begin_src elisp
  (use-package centaur-tabs
    :disabled t
    :ensure t
    :bind
    ("s-}" . centaur-tabs-forward)
    ("s-{" . centaur-tabs-backward)
    ("M-s-<left>" . centaur-tabs-backward)
    ("M-s-<right>" . centaur-tabs-forward)
    :config
    (setq centaur-tabs-set-icons t
          centaur-tabs-icon-type 'all-the-icons
          centaur-tabs-style "bar"
          centaur-tabs-height 20
          centaur-tabs-set-bar 'left
          centaur-tabs-set-close-button nil
          centaur-tabs-show-new-tab-button nil
          centaur-tabs-cycle-scope 'tabs
          centaur-tabs-set-modified-marker t)
    (centaur-tabs-change-fonts "DroidSansM Nerd Font" 100)
    :init
    (centaur-tabs-mode -1) ;; off for now
    :hook
    ;; turn off centaur tabs in these modes
    (dired-mode . centaur-tabs-local-mode)
    (vterm-mode . centaur-tabs-local-mode))
#+end_src

#+RESULTS:
: centaur-tabs-forward

** Windows

Delete a window more easily
#+begin_src elisp
  (define-key my/window-map "d" '("delete" . delete-window))
#+end_src

#+begin_src elisp
  (keymap-set my/window-map "m" '("maximize" . maximize-window))
#+end_src

*** neotree
https://github.com/jaypei/emacs-neotree
#+begin_src elisp
  (use-package neotree
    :ensure t
    :defer t
    :config
     (defun neotree-project-dir ()
       "Open NeoTree using the git root."
       (interactive)
       (let ((project-dir (projectile-project-root))
             (file-name (buffer-file-name)))
         (neotree-toggle)
         (if project-dir
             (if (neo-global--window-exists-p)
                 (progn
  		 (neotree-dir project-dir)
  		 (neotree-find file-name)))
  	 (message "Could not find git project root."))))
    :custom
    (neo-theme 'icons)
    (neo-window-fixed-size nil)
    :bind
    ("C-<f8>" . neotree-project-dir)
    ("<f8>" . neotree-project-dir))
#+end_src

#+RESULTS:
: neotree-project-dir

*** treemacs
#+begin_src elisp
  (use-package treemacs
    :disabled t
    :ensure t
    :defer t
    :config
    (progn
      (setq treemacs-collapse-dirs                   (if treemacs-python-executable 3 0)
            treemacs-deferred-git-apply-delay        0.5
            treemacs-directory-name-transformer      #'identity
            treemacs-display-in-side-window          t
            treemacs-eldoc-display                   'simple
            treemacs-file-event-delay                2000
            treemacs-file-extension-regex            treemacs-last-period-regex-value
            treemacs-file-follow-delay               0.2
            treemacs-file-name-transformer           #'identity
            treemacs-follow-after-init               t
            treemacs-expand-after-init               t
            treemacs-find-workspace-method           'find-for-file-or-pick-first
            treemacs-git-command-pipe                ""
            treemacs-goto-tag-strategy               'refetch-index
            treemacs-header-scroll-indicators        '(nil . "^^^^^^")
            treemacs-hide-dot-git-directory          t
            treemacs-indentation                     2
            treemacs-indentation-string              " "
            treemacs-is-never-other-window           nil
            treemacs-max-git-entries                 5000
            treemacs-missing-project-action          'ask
            treemacs-move-files-by-mouse-dragging    t
            treemacs-move-forward-on-expand          nil
            treemacs-no-png-images                   nil
            treemacs-no-delete-other-windows         t
            treemacs-project-follow-cleanup          nil
            treemacs-persist-file                    (expand-file-name ".cache/treemacs-persist" user-emacs-directory)
            treemacs-position                        'left
            treemacs-read-string-input               'from-child-frame
            treemacs-recenter-distance               0.1
            treemacs-recenter-after-file-follow      nil
            treemacs-recenter-after-tag-follow       nil
            treemacs-recenter-after-project-jump     'always
            treemacs-recenter-after-project-expand   'on-distance
            treemacs-litter-directories              '("/node_modules" "/.venv" "/.cask")
            treemacs-project-follow-into-home        nil
            treemacs-show-cursor                     nil
            treemacs-show-hidden-files               t
            treemacs-silent-filewatch                nil
            treemacs-silent-refresh                  nil
            treemacs-sorting                         'alphabetic-asc
            treemacs-select-when-already-in-treemacs 'move-back
            treemacs-space-between-root-nodes        t
            treemacs-tag-follow-cleanup              t
            treemacs-tag-follow-delay                1.5
            treemacs-text-scale                      nil
            treemacs-user-mode-line-format           nil
            treemacs-user-header-line-format         nil
            treemacs-wide-toggle-width               70
            treemacs-width                           35
            treemacs-width-increment                 1
            treemacs-width-is-initially-locked       t
            treemacs-workspace-switch-cleanup        nil)

      ;; The default width and height of the icons is 22 pixels. If you are
      ;; using a Hi-DPI display, uncomment this to double the icon size.
      ;;(treemacs-resize-icons 44)

      (treemacs-follow-mode t)
      (treemacs-filewatch-mode t)
      (treemacs-fringe-indicator-mode 'always)
      (when treemacs-python-executable
        (treemacs-git-commit-diff-mode t))

      (pcase (cons (not (null (executable-find "git")))
                   (not (null treemacs-python-executable)))
        (`(t . t)
         (treemacs-git-mode 'deferred))
        (`(t . _)
         (treemacs-git-mode 'simple)))

      (treemacs-hide-gitignored-files-mode nil))
    :bind
    ("C-<f8>" .  treemacs-add-and-display-current-project-exclusively)
    (:map global-map
          ("M-0"       . treemacs-select-window)
          ("C-x t 1"   . treemacs-delete-other-windows)
          ("C-x t t"   . treemacs)
          ("C-x t d"   . treemacs-select-directory)
          ("C-x t B"   . treemacs-bookmark)
          ("C-x t C-t" . treemacs-find-file)
          ("C-x t M-t" . treemacs-find-tag)))
#+end_src

#+RESULTS:

Use all-the-icons
#+begin_src elisp
  (use-package treemacs-all-the-icons
    :after (treemacs)
    :ensure t)
#+end_src


*** eyebrowse
#+begin_src elisp
  (use-package eyebrowse
    :ensure t
    :init (eyebrowse-mode 1))
#+end_src

*** ace window
#+begin_src elisp
  (use-package ace-window
    :ensure t
    :bind    
    (:map my/window-map
          ("w" . ace-window)
          ("u" . winner-undo)))
#+end_src


** Search
#+begin_src elisp
  (use-package avy
    :ensure t
    :bind
    ("C-s" . avy-goto-char)
    ("C-'" . avy-resume)
    ("C-t" . avy-goto-char-timer)
    ("C-S-F" . avy-goto-char)
    (:map my/goto-map
          ("l" . avy-goto-line)
          ("t" . avy-goto-char-timer)
          ("'" . avy-resume)))
#+end_src

#+begin_src elisp
  (use-package rg
    :ensure t
    :config
    ;; TODO -- suffix for not ignoring bitbucket vendors
    
    ;; put an option to ignore vendor files
    (transient-insert-suffix 'rg-menu "-h" '(1 "-v" "No vendor" "--glob='!vendor/*'"))

    ;; this is for the RESULTS buffer
    ;; on by default, ignores vendor
    (rg-define-toggle "--glob='!vendor/*'" "v" t)
    ;; off by default, ignores test files
    (rg-define-toggle "--glob='!*test.go' --glob='!*.test.ts'" (kbd "C-c t"))

    
    (rg-define-search search-ignore-vendor-test
      "Ignore vendor and test directories for the search"
      :query ask
      :files current ; use the current buffer's file type to find it
      :dir project
      :flags ("--glob '!vendor/*'" "--glob '!*test*'"))
    
    (rg-menu-transient-insert "Search" "f" "Project" 'search-ignore-vendor-test)
    (rg-enable-default-bindings (kbd "C-c r")))

#+end_src

Better-jumper allows us to set marks and jump around pretty easily
#+begin_src elisp
  (use-package better-jumper
    :ensure t
    ;; set up the keymap for jumper if it's enabled
    :config
    (setq my/jump-map (make-sparse-keymap))
    (define-key global-map (kbd "C-j") `("jump" . ,my/jump-map))
    :bind
    (:map my/jump-map
  		("C-f" . better-jumper-jump-forward)
  		("C-b" . better-jumper-jump-backward)
  		("C-j" . better-jumper-set-jump)))
#+end_src

#+RESULTS:

* Convenience functions
Surround the region in some characters, attempting to find matches
#+begin_src elisp
  (defun surround/matching (c)
    (cond ((eq ?\( c) ?\))
          ((eq ?\[ c) ?\])
          ((eq ?\{ c) ?\})
          ((eq ?\< c) ?\>)
          (t c))) ;; default is to just drop in the character

  (defun surround-region (start end char)
    "Insert `char' (and maybe its matching closing character) around a region
  defined by `start' and `end'."
    (interactive "r\ncSurround:")
    (if (eq char ?\e)	; allow escape to exit input
  	    (deactivate-mark) ; and abort the mark	
      (save-excursion
        (goto-char start)
        (insert char)
        (goto-char (1+ end))
        (insert (surround/matching char)))))

#+end_src

Allow for marking the symbol as separated by spaces
#+begin_src elisp
  (defun my/find-symbol-boundaries (point)
    (let* ((start point) (end point)
  	 (whitespace '(?\s ?\t ?\n ?\f ?\r)))
  	
      (while (not (-contains? whitespace (char-before start)))
        (setq start (1- start)))
      (while (not (-contains? whitespace (char-after end)))
        (setq end (1+ end)))
      (list start end)))

   (defun my/highlight-symbol-boundary (point)
     (interactive "d")
     (let* ((points (my/find-symbol-boundaries point))
  	   (start (car points))
  	   (end (cadr points)))
       (goto-char start)
       (set-mark start)
       (goto-char end)))

  (define-key global-map (kbd "C-M-w") #'my/highlight-symbol-boundary) ; global is good here
#+end_src

#+RESULTS:
: my/highlight-symbol-boundary

Allow moving forward or back based on the symbol's boundary
#+begin_src elisp
  (defun my/move-forward-to-boundary (point)
    (interactive "d")
    (let ((end (cadr (my/find-symbol-boundaries point))))
      (goto-char end)))

  (defun my/move-backward-to-boundary (point)
    (interactive "d")
    (let ((start (car (my/find-symbol-boundaries point))))
      (goto-char start)))
#+end_src

#+RESULTS:
: my/move-backward-to-boundary

Copy file name
#+begin_src elisp
      (defun copy-filename ()
        (interactive)
        (kill-new (buffer-file-name)))
#+end_src

* God mode
Function to delete the marked text and exit god mode (similar to =C= in vim)
#+begin_src elisp
  (defun my/god-mode-change ()
    (interactive)
    (when (region-active-p)
      (kill-region (region-beginning) (region-end))
      (god-local-mode -1)))
#+end_src

#+RESULTS:
: my/god-mode-change


https://github.com/emacsorphanage/god-mode
#+begin_src elisp
  (use-package god-mode
    :ensure t
    :bind
    ("<escape>" . #'god-mode-all)
    ("C-z" . repeat)
    ("C-<f3>" . kmacro-start-macro-or-insert-counter)
    ("C-<f4>" . kmacro-end-or-call-macro)
    (:map god-local-mode-map
  	("S" . surround-region)
          ("i" . god-mode-all)
          ("a" . beginning-of-line-text)
          ("[" . backward-paragraph)
          ("]" . forward-paragraph)
          ("C" . my/god-mode-change))
    :chords
    ("jk" . god-mode-all)
    :config
    (setq god-mode-alist '((nil . "C-") ("m" . "M-") ("M" . "C-M-")))

    (defun god-mode-cursor ()
      (if god-local-mode
          (setq-local cursor-type 'box)
        (setq-local cursor-type 'bar)))
    (add-hook 'post-command-hook #'god-mode-cursor)
    :init
    (god-mode))
#+end_src

#+RESULTS:
: t


* Hyperbole
Hyperbole seems awesome
Reference [[https://www.gnu.org/s/hyperbole/#summary][here]]

#+begin_src elisp
  (use-package hyperbole
    :ensure t
    :defer t
    :init
    (hyperbole-mode 1))
#+end_src

* yas
Create a yas keymap
#+begin_src elisp
  (setq my/yas-map (make-sparse-keymap))
  (define-key global-map (kbd "C-c C-y") `("yas" . ,my/yas-map))
  #+end_src

  #+RESULTS:
  | yas | keymap |

#+begin_src elisp
  (use-package yasnippet
    :ensure t
    :bind
    (:map my/yas-map
  	  ("n" . yas-new-snippet)
  	  ("s" . yas-insert-snippet))
    :config (yas-global-mode 1))
#+end_src

#+RESULTS:
: yas-insert-snippet

* Quick reload changes
#+begin_src elisp
  (defun reload()
    (interactive)
    (org-babel-load-file (expand-file-name "~/emacs/bedrock-config/config.org"))
    (load (expand-file-name "~/emacs/bedrock-config/config.el")))
#+end_src 

#+RESULTS:
: reload

* Completion

[[https://kristofferbalintona.me/posts/202202211546/#extensions][This post]] is a fantastic reference

** Vertico
#+begin_src elisp
  (use-package vertico
    :ensure t
    :custom
    (vertico-count 20) ;; Show more candidates
    (vertico-resize t) ;; Grow and shrink the Vertico minibuffer
    (vertico-cycle t) ;; Enable cycling for `vertico-next/previous'
    :config ; evaluated after the pkg loads
    ;; (keymap-set vertico-map "TAB" #'vertico-next)
    ;; (keymap-set vertico-map "<backtab>" #'vertico-previous)
    :bind
    (("C-c '" . vertico-suspend)
     (:map vertico-map
           ("<escape>" . abort-recursive-edit)
           ("<tab>" . vertico-next)
       ("C-i" . vertico-quick-insert)
       ("C-o" . vertico-quick-exit)
       ;; keeping these on so that I can test out which I like best for multiform modes
       ("M-B" . vertico-multiform-buffer)
       ("M-F" . vertico-multiform-flat)
       ("M-G" . vertico-multiform-grid)
       ("M-R" . vertico-multiform-reverse)
       ("M-V" . vertico-multiform-vertical)
       ("M-U" . vertico-multiform-unobtrusive)
     ))
    :init
  (vertico-mode 1))
#+end_src

#+RESULTS:
: vertico-multiform-unobtrusive

*** Extensions
#+begin_src elisp
  (use-package vertico-suspend
    :after vertico
    :ensure nil)
  
  (use-package vertico-repeat
    :after vertico
    :ensure nil)

  (use-package vertico-directory
    :after vertico
    :bind
    (:map vertico-map
     ("M-DEL" . vertico-directory-up)
   ("RET" . vertico-directory-enter)))

#+end_src

#+RESULTS:
: vertico-directory-enter

*** Multiform
Change the way vertico looks based on the command I'm using
#+begin_src elisp
  (use-package vertico-multiform
    :after vertico
    :ensure nil
    :custom
    
    (vertico-multiform-commands
  	 '(
  	   (consult-imenu buffer indexed)
  	   (consult-project-buffer reverse)
  	   (find-file reverse)
  	   
  	   (xref-find-references flat)
  	   ))
    :init
    (vertico-multiform-mode)
    )
    
#+end_src

#+RESULTS:


** Orderless
#+begin_src elisp
    (use-package orderless
      :ensure t
      :custom
      (completion-styles '(orderless basic))
      (completion-category-defaults nil)
      (completion-category-overrides '((file (styles basic partial-completion))
  				     (lsp-capf (styles orderless)))))
#+end_src

#+RESULTS:

** Completion
Using tab-and-go completion style

*** Company
#+begin_src elisp
  (use-package company
    :disabled t
    :ensure t
    :config
    (setq company-tooltip-align-annotations t
  		 ;;         company-show-quick-access t
          company-files-exclusions '(".git/" ".DS_Store")
          ;; use letters instead of icons
          company-format-margin-function #'company-text-icons-margin
          company-text-icons-add-background t
          ;; make it so that I do it myself, please
          company-idle-delay 0.3)
    ;; customize the annotation faces
    ;; (custom-set-faces
    ;;  '(company-tooltip-annotation ((t (:foreground "dark gray")))))
    ;; (
     (setq company-backends '((:separate company-yasnippet company-capf company-keywords)))
    :bind
    ("M-i" . company-manual-begin)
    (:map company-active-map
          ([tab] . company-complete-common-or-cycle)
          ("<escape>" . company-abort))
    :init
    (global-company-mode 1))
#+end_src

#+RESULTS:
: company-abort

Company-box shows nice popups (and documentation) for selection candidates
#+begin_src elisp
  (use-package company-box
    :disabled t
    :ensure t
    :requires company
    :config
    (setq company-box-doc-delay 0.8)
    :hook (company-mode . company-box-mode))
#+end_src

Really turn off company mode
#+begin_src elisp
  ;; (defun turn-off-company ()
  ;;   (company-mode -1))
  ;;   (add-hook 'prog-mode-hook #'turn-off-company)
#+end_src


#+RESULTS:
| turn-off-company | hl-todo-mode | rainbow-delimiters-mode | highlight-indent-guides-mode | hl-line-mode | display-line-numbers-mode |


*** Corfu

Not using it for now, trying out company
#+begin_src elisp
      (use-package corfu
        :ensure t
        :custom
        (corfu-cycle t)
        (corfu-preselect 'first)
        (corfu-preview-current nil)
        (corfu-quit-at-boundary 'separator)
        (corfu-on-exact-match 'quit)
        (corfu-auto t)
        (corfu-quit-no-match t)
        ;; corfu popup
        (corfu-popupinfo-mode t)
        (corfu-popupinfo-delay '(1.0 . 0.5))
        :config
        :bind
        (:map corfu-map
            ("M-SPC" . corfu-insert-separator)
            ("TAB" . corfu-next)
            ([tab] . corfu-next)
            ("S-TAB" . corfu-previous)
            ([backtab] . corfu-previous)
    	("<return>" . corfu-insert)
  	("<escape>" . corfu-quit))
        :init
        (global-corfu-mode 1)
        (corfu-popupinfo-mode))
#+end_src

#+RESULTS:
: corfu-quit


*** Cape
https://github.com/minad/cape
#+begin_src elisp
    (use-package cape
  	:disabled
  	:ensure t
    ;; Bind prefix keymap providing all Cape commands under a mnemonic key.
    ;; Press C-c p ? to for help.
    :bind ("C-c C-p" . cape-prefix-map) ;; Alternative key: M-<tab>, M-p, M-+
    ;; Alternatively bind Cape commands individually.
    ;; :bind (("C-c p d" . cape-dabbrev)
    ;;        ("C-c p h" . cape-history)
    ;;        ("C-c p f" . cape-file)
    ;;        ...)
    :init
    ;; Add to the global default value of `completion-at-point-functions' which is
    ;; used by `completion-at-point'.  The order of the functions matters, the
    ;; first function returning a result wins.  Note that the list of buffer-local
    ;; completion functions takes precedence over the global list.
    (add-hook 'completion-at-point-functions #'cape-dabbrev)
    (add-hook 'completion-at-point-functions #'cape-file)
    (add-hook 'completion-at-point-functions #'cape-elisp-block)
    ;; (add-hook 'completion-at-point-functions #'cape-history)
    ;; ...
  )
#+end_src


#+RESULTS:
: cape-prefix-map

** Consult
A function to search the current directory. If something is under point, suggest that as default
#+begin_src elisp
  (defun search/dir ()
    (interactive)
    (let ((dir (file-name-directory (buffer-file-name))))
      (consult-ripgrep dir)))
#+end_src

Taken from the consult wiki: https://github.com/minad/consult/wiki
Make any previews interactive
#+begin_src elisp
  (define-key minibuffer-local-map (kbd "M-.") #'my-embark-preview)
  (defun my-embark-preview ()
    "Previews candidate in vertico buffer, unless it's a consult command"
    (interactive)
    (unless (bound-and-true-p consult--preview-function)
      (save-selected-window
        (let ((embark-quit-after-action nil))
          (embark-dwim)))))
#+end_src

TODO:
Custom consult function to use eyebrowse

#+begin_src elisp
  (use-package consult
    :ensure t
    :bind
    ;; meow SPC x b
    (("C-c b" . consult-bookmark)
     ("C-S-Y" . consult-yank-from-kill-ring)
     ("M-'" . consult-register-store)
     ("M-\"" . consult-register)
     :map my/consult-map
          (("b" . consult-project-buffer)
          ("B" . consult-buffer)
          ("l" . consult-line)
          ("f" . consult-recent-file)
          ("o" . consult-outline)
          ("i" . consult-imenu)
          ("I" . consult-imenu-multi)
          ("r" . consult-ripgrep)
          ("d" . search/dir))
          :map my/goto-map
          (("L" . consult-goto-line))
          :map my/window-map
          (("b" . consult-buffer-other-window)))
    :init
    (setq consult-narrow-key (kbd "<")))
#+end_src

#+RESULTS:
: consult-buffer-other-window

Set these on the global keymap, overriding the existing ones
#+begin_src elisp
  (define-key global-map (kbd "C-c C-r") #'consult-register-load)
#+end_src


#+RESULTS:
: consult-register-load

Use consult-xref for xref! So great
#+begin_src elisp
  (use-package consult-xref
    :ensure nil
    :after consult
    :config
    (setq xref-show-xrefs-function #'consult-xref))
#+end_src

#+RESULTS:
: t


** Marginalia
#+begin_src elisp
  ;; Enable rich annotations using the Marginalia package
  (use-package marginalia
    :ensure t
    ;; Bind `marginalia-cycle' locally in the minibuffer.  To make the binding
    ;; available in the *Completions* buffer, add it to the
    ;; `completion-list-mode-map'.
    :bind (:map minibuffer-local-map
                ("M-A" . marginalia-cycle))

    ;; The :init section is always executed.
    :init

    ;; Marginalia must be activated in the :init section of use-package such that
    ;; the mode gets enabled right away. Note that this forces loading the
    ;; package.
    (marginalia-mode))
#+end_src

** Embark
#+begin_src elisp
  (use-package embark
    :ensure t
    :bind
    (("C-." . embark-act)         ;; pick some comfortable binding
     ("C-;" . embark-dwim)        ;; good alternative: M-.
     ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

    :init

    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)

    ;; Show the Embark target at point via Eldoc. You may adjust the
    ;; Eldoc strategy, if you want to see the documentation from
    ;; multiple providers. Beware that using this can be a little
    ;; jarring since the message shown in the minibuffer can be more
    ;; than one line, causing the modeline to move up and down:

    ;; (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
    ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)

    :config

    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))
  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :ensure t ; only need to install it, embark loads it after consult if found
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

* magit
#+begin_src elisp
    (use-package magit
      :ensure t
      :bind
      (("C-M-g" . magit)
       ("C-M-b" . magit-checkout)))
#+end_src


* Terminal

** vterm
#+begin_src elisp
    (use-package vterm
      :ensure t
      :bind
      (("C-c v" . vterm)
      ("C-c V" . vterm-other-window)))
#+end_src

* Languages

** Flycheck
Define a keymap for errors
#+begin_src elisp
  (setq my/errors-map (make-sparse-keymap))
  (define-key global-map (kbd "C-c e") `("errors" . ,my/errors-map))
#+end_src

#+begin_src elisp
  (use-package flycheck
    :ensure t
    :bind
    (:map my/errors-map
     ("n" . flycheck-next-error)
     ("p" . flycheck-previous-error)
     ("l" . flycheck-list-errors)
     ("h" . display-local-help))
    :init (global-flycheck-mode))
#+end_src

** markdown
#+begin_src elisp
  (use-package markdown-mode
    :ensure t
    :mode ("README\\.md\\'" . gfm-mode)
    :init (setq markdown-command "multimarkdown"))
#+end_src

** treesit
#+begin_src elisp
  (setq treesit-language-source-alist
        '((gomod "https://github.com/camdencheek/tree-sitter-go-mod")
          (go "https://github.com/tree-sitter/tree-sitter-go" "v0.19.1")
          (tsx . ("https://github.com/tree-sitter/tree-sitter-typescript"
           "v0.20.3"
           "tsx/src"))
          (typescript "https://github.com/tree-sitter/tree-sitter-typescript"
                    "v0.20.3"
                    "typescript/src")
          (elisp "https://github.com/Wilfred/tree-sitter-elisp")
          (templ . ("https://github.com/vrischmann/tree-sitter-templ"))
          (javascript . ("https://github.com/tree-sitter/tree-sitter-javascript"))))

  (setq treesit-font-lock-level 4)
#+end_src

** yaml
#+begin_src elisp
  (use-package yaml-mode
    :ensure t)
#+end_src

** DAP mode
Should allow for debugging and stepping through code
Github repo: https://github.com/emacs-lsp/dap-mode
Webiste: https://emacs-lsp.github.io/dap-mode/
#+begin_src elisp
      (use-package dap-mode
        :ensure t)
#+end_src

*** node
Need the node setup
#+begin_src elisp
          (use-package dap-node
            :requires dap-mode
            :after dap-mode
    	:config
  	(dap-node-setup))
#+end_src

Use the chrome setup too, since the chrome debugger is nice
#+begin_src elisp
    (use-package dap-chrome
      :requires dap-mode
      :after dap-mode
      :config
      (dap-chrome-setup))
#+end_src


A configuration to run the tests with debug enabled
#+begin_src elisp
  (dap-register-debug-template
   "debug tests"
   (list :type "node"
         :request "launch"
         :args  '("--inspect-brk" "/opt/homebrew/bin/jest" "--runInBand")
         :name "Debug tests"))
#+end_src

A configuration to simply run a file
#+begin_src elisp
  (dap-register-debug-template
   "Node run file"
   (list :type "node"
   :request "launch"
   :program "${workspaceFolder}/local/run-query.ts"
   :args nil
   :name "node run"))
#+end_src

TS-node config, for changing on the fly
#+begin_src elisp
  ;; TODO: make this an interactive function to run the debug configuration
   (dap-register-debug-template
    "TS run"
  (list :name "TS Index"
        :type "node"
        :request "launch"
        :args (expand-file-name "~/j1/query-domain/local/run-query.ts")
        :runtimeArgs ["--nolazy" "-r" "ts-node/register"]
        :sourceMaps t
        :cwd (expand-file-name "~/j1/query-domain")
        :protocol "inspector"))
#+end_src



#+RESULTS:
| TS run                 | :name | TS Index | :type    | node   | :request | launch                                             | :args    | /Users/jonlasley/j1/query-domain/local/run-query.ts | :runtimeArgs | [--nolazy -r ts-node/register] | :sourceMaps | t | :cwd | /Users/jonlasley/j1/query-domain | :protocol | inspector |
| Node::Run              | :type | node     | :cwd     | nil    | :request | launch                                             | :program | /Users/jonlasley/j1/query-domain/local/run-query.ts | :name        | Node::Run                      |             |   |      |                                  |           |           |
| Node run file          | :type | node     | :request | launch | :program | ${workspaceFolder}/local/run-query.ts              | :args    | nil                                                 | :name        | node run                       |             |   |      |                                  |           |           |
| debug tests            | :type | node     | :request | launch | :args    | (--inspect-brk /opt/homebrew/bin/jest --runInBand) | :name    | Debug tests                                         |              |                                |             |   |      |                                  |           |           |
| Node Run Configuration | :type | node     | :cwd     | nil    | :request | launch                                             | :program | nil                                                 | :name        | Node::Run                      |             |   |      |                                  |           |           |


** lsp
Format and organize before saving

#+begin_src elisp
  (defun lsp-format-and-organize-imports ()
    (add-hook 'before-save-hook #'lsp-format-buffer t t)
    (add-hook 'before-save-hook #'lsp-organize-imports t t))
#+end_src

Don't watch vendor dirs
#+begin_src elisp
    (defun lsp-ignore-vendor ()
      (add-to-list lsp-file-watch-ignored-directories "[/\\\\]vendor"))
#+end_src


#+begin_src elisp
  (use-package lsp-mode
    :ensure t
    :config
    (setq lsp-headerline-breadcrumb-enable t
          lsp-enable-file-watchers nil
          ;; show warns in flycheck
          lsp-diagnostics-flycheck-default-level 'warning)
    (add-to-list 'lsp-file-watch-ignored-files "[/\\\\].*~$")
    :hook
    ;; go
    ((go-mode . lsp-deferred)
     (go-mode . lsp-format-and-organize-imports)
     ;; (go-mode . lsp-ignore-vendor)
     (tsx-ts-mode . lsp-deferred)
     (rust-mode . lsp-deferred)
     (go-mode . lsp-format-and-organize-imports)))
#+end_src

#+RESULTS:
| go-guru-hl-identifier-mode | #[nil ((flycheck-golangci-lint-setup) (setq flycheck-local-checkers '((lsp (next-checkers golangci-lint))))) nil] | flycheck-golangci-lint-setup | lsp-format-and-organize-imports | lsp-deferred | doom-modeline-env-setup-go |

*** LSP extensions
Peek is awesome
#+begin_src elisp
      (use-package lsp-ui
        :ensure t
        :config
        (setq lsp-ui-doc-delay 1)
        :bind
        (:map lsp-ui-mode-map
              ("M-." . lsp-ui-peek-find-definitions)
              ("M-?" . lsp-ui-peek-find-references)
  	    ("M-s C-i" . lsp-ui-imenu)))
#+end_src

*** Consult LSP
Allow searching the LSP symbols with Consult
#+begin_src elisp
          (use-package consult-lsp
            :ensure t
            :bind
            (:map my/consult-map
                  ("s" . consult-lsp-symbols)))
#+end_src

*** lsp-booster
Speed up JSON parsing in lsp mode
[[https://github.com/blahgeek/emacs-lsp-booster?tab=readme-ov-file][Reference]]

#+begin_src elisp
  (defun lsp-booster--advice-json-parse (old-fn &rest args)
  "Try to parse bytecode instead of json."
  (or
   (when (equal (following-char) ?#)
     (let ((bytecode (read (current-buffer))))
       (when (byte-code-function-p bytecode)
         (funcall bytecode))))
   (apply old-fn args)))
(advice-add (if (progn (require 'json)
                       (fboundp 'json-parse-buffer))
                'json-parse-buffer
              'json-read)
            :around
            #'lsp-booster--advice-json-parse)

(defun lsp-booster--advice-final-command (old-fn cmd &optional test?)
  "Prepend emacs-lsp-booster command to lsp CMD."
  (let ((orig-result (funcall old-fn cmd test?)))
    (if (and (not test?)                             ;; for check lsp-server-present?
             (not (file-remote-p default-directory)) ;; see lsp-resolve-final-command, it would add extra shell wrapper
             lsp-use-plists
             (not (functionp 'json-rpc-connection))  ;; native json-rpc
             (executable-find "emacs-lsp-booster"))
        (progn
          (when-let ((command-from-exec-path (executable-find (car orig-result))))  ;; resolve command from exec-path (in case not found in $PATH)
            (setcar orig-result command-from-exec-path))
          (message "Using emacs-lsp-booster for %s!" orig-result)
          (cons "emacs-lsp-booster" orig-result))
      orig-result)))
(advice-add 'lsp-resolve-final-command :around #'lsp-booster--advice-final-command)
#+end_src


** Go
Also get go-mode
#+begin_src elisp
  (use-package go-mode
    :config
    (setq lsp-go-use-gofumpt t)
    :bind
    (:map go-mode-map
    ("C-c C-d" . godoc-at-point))
    :ensure t)
#+end_src

Golangci-lint
#+begin_src elisp
    (use-package flycheck-golangci-lint
      :ensure t
      :hook (go-mode . flycheck-golangci-lint-setup))


(add-hook 'go-mode-hook (lambda()
                            (flycheck-golangci-lint-setup)
                            (setq flycheck-local-checkers '((lsp . ((next-checkers . (golangci-lint))))))))
#+end_src


#+begin_src elisp
  (add-to-list 'auto-mode-alist '("\\.go" . go-mode))
  (add-to-list 'major-mode-remap-alist '(go-ts-mode . go-mode))
  (add-hook 'go-mode #'lsp-format-and-organize-imports)
#+end_src

go-eldoc
#+begin_src elisp
  (use-package go-eldoc
    :ensure t
    :disabled
    :hook
    (go-mode . go-eldoc-setup))
#+end_src

#+begin_src elisp
  (use-package go-guru
    :ensure t
    :hook
    (go-mode . go-guru-hl-identifier-mode))
#+end_src

go-fill-struct is just realy nice
Requires =go get -u github.com/davidrjenni/reftools/cmd/fillstruct=
#+begin_src elisp
    (use-package go-fill-struct
      :ensure t)
#+end_src



*** templ
#+begin_src elisp
  (use-package templ-ts-mode
    :ensure t)
#+end_src


** Rust
#+begin_src elisp
          (use-package rust-mode
            :ensure t
            :hook
            (rust-mode . lsp-))
#+end_src

** JavaScript

#+begin_src elisp
  (add-to-list 'auto-mode-alist '("\\.[jt]sx?" . tsx-ts-mode)) ; going to try out webmode for a little, think it will be nice
    (add-hook 'tsx-ts-mode-hook #'lsp-deferred)
#+end_src

add the same hooks for typescript-ts-mode
#+begin_src elisp
  (add-hook 'typescript-ts-mode-hook #'lsp-deferred)
#+end_src


#+RESULTS:
| lsp-deferred |

[[https://web-mode.org/][Web mode]] is sick
#+begin_src elisp
  (use-package web-mode
    :ensure t
    :disabled t
    :hook
    (web-mode . lsp-deferred)
    (web-mode . lsp-format-and-organize-imports)
    :config
    (add-to-list 'auto-mode-alist '("\\.[tj]sx" . web-mode)))
#+end_src

*** playground
Spin up a quick buffer to edit a reusable JS file for playground stuff
#+begin_src elisp
  (defun open-playground-file ()
    (interactive)
    ;; TODO: minor mode for keymaps for running?
    (let ((file (expand-file-name "~/playground/playground.js")))
      (find-file-other-window file)))

  (defun node-run-region (beg end)
    ;; TODO: needs some work
    (interactive "r")
    (let ((output (get-buffer-create "*node output*")))
      (message "%s %s" beg end)
      (shell-command-on-region beg end "node -e" output nil output t nil)))

  (defun node-run-file (file)
    (interactive (list (read-string "File: " (buffer-file-name))))
    (let ((cmd (format "node %s" (shell-quote-argument (expand-file-name file))))
  	(output (get-buffer-create "*node output*")))
      (shell-command cmd output output)))
#+end_src

#+RESULTS:
: node-run-file


*** jest
#+begin_src elisp
          (use-package jest
            :ensure t
            :hook
    	(tsx-ts-mode . jest-minor-mode)
  	(typescript-ts-mode . jest-minor-mode))
#+end_src

#+RESULTS:


*** Prettier

#+begin_src elisp
  (use-package prettier
    :ensure t
    :defer t
    :hook
    (web-mode . prettier-mode)
    (tsx-ts-mode . prettier-mode)
    (typescript-ts-mode . prettier-mode))
#+end_src

#+RESULTS:
| prettier-mode | lsp-deferred |

*** Tide mode
Reference: https://github.com/ananthakumaran/tide
#+begin_src elisp
  (use-package tide
    :ensure t
    :defer t
  :config
    (defun setup-tide-mode ()
    (interactive)
    (tide-setup)
    (flycheck-mode +1)
    (setq flycheck-check-syntax-automatically '(save mode-enabled))
    (eldoc-mode +1)
    (tide-hl-identifier-mode +1))
    ;; company is an optional dependency. You have to
    ;; install it separately via package-install
    ;; `M-x package-install [ret] company`

  ;; aligns annotation to the right hand side
  (setq company-tooltip-align-annotations t)

  ;; formats the buffer before saving
  (add-hook 'before-save-hook 'tide-format-before-save)

  ;; if you use typescript-mode
  (add-hook 'typescript-mode-hook #'setup-tide-mode)
  ;; if you use treesitter based typescript-ts-mode (emacs 29+)
  (add-hook 'typescript-ts-mode-hook #'setup-tide-mode))
#+end_src


** Clojure mode
#+begin_src elisp
    (use-package clojure-mode
      :ensure t
      :custom
      (setq lsp-clojure-server-command '("/opt/homebrew/bin/clojure-lsp"))
  :hook
  (clojure-mode . lsp-deferred))
#+end_src

Paredit is awesome
#+begin_src elisp
  (use-package paredit-mode
    :hook
    (clojure-mode . paredit-mode))
#+end_src

Cider enables running a REPL in a project (among other things)
Reference [[https://github.com/clojure-emacs/cider][here]]
#+begin_src elisp
    (use-package cider
      :ensure t)
#+end_src


*** PKL
[[https://github.com/sin-ack/pkl-mode][Reference]]
#+begin_src elisp
  ;; requires a custom language server
  (with-eval-after-load 'lsp-mode
    (add-to-list 'lsp-language-id-configuration '(pkl-mode . "pkl"))

    ;; add the server
    (lsp-register-client (make-lsp-client
            :new-connection (lsp-stdio-connection '("java" "-jar" "/Users/LASLEJX1/.pkl/lsp.jar"))
            :activation-fn (lsp-activate-on "pkl")
            :server-id 'pkl)))



  ;; (use-package pkl-mode
  ;;   :vc (:url "https://github.com/sin-ack/pkl-mode" :rev :newest)
  ;;   :hook
  ;;   (pkl-mode . lsp-deferred))
#+end_src

#+RESULTS:
| lsp-deferred |

LSP configuration
#+begin_src elisp
#+end_src

#+RESULTS:



** One-off languages (no LSP)
=fsh= mode
#+begin_src elisp
  (use-package fish-mode :ensure t)
#+end_src

*** Docker
#+begin_src elisp
  (use-package dockerfile-mode :ensure t)
#+end_src

#+RESULTS:

*** terraform
#+begin_src elisp
        (use-package terraform-mode
          :ensure t
          :custom (terraform-indent-level 4))
#+end_src

#+RESULTS:




* AI
People on the emacs subreddit have only good things to say about [[https://github.com/tninja/aider.el][aider.el]]
#+begin_src elisp
    (use-package aider
    :vc (:url "https://github.com/tninja/aider.el")
    :config
    ;; For latest claude sonnet model
    ;; (setq aider-args '("--model" "sonnet" "--no-auto-accept-architect"))
    ;; (setenv "ANTHROPIC_API_KEY" anthropic-api-key)
    ;; Or chatgpt model
    ;; (setq aider-args '("--model" "o4-mini"))
    ;; (setenv "OPENAI_API_KEY" "TODO")
  ;;  Or gemini model
    ;; (setq aider-args '("--model" "gemini-exp"))
    ;; (setenv "GEMINI_API_KEY" <your-gemini-api-key>)
    ;; Or use your personal config file
    (setq aider-args `("--config" ,(expand-file-name "~/emacs/bedrock-config/aider.conf.yml")))
    ;; ;;
    ;; Optional: Set a key binding for the transient menu
    (global-set-key (kbd "C-c a") 'aider-transient-menu))
#+end_src

** Claude code
https://github.com/stevemolitor/claude-code.el
#+begin_src elisp
  (use-package claude-code :ensure t
    :vc (:url "https://github.com/stevemolitor/claude-code.el" :rev :newest)
    :config (claude-code-mode)
    :custom
    (claude-code-terminal-backend 'vterm)
    :bind ("C-c c" . claude-code-transient))  
#+end_src

#+RESULTS:
: claude-code-transient



* Formatters

LSP formats, but sometimes you don't want LSP
Apheleia helps with that
#+begin_src elisp
  (use-package apheleia
    :ensure t
    :init
    (apheleia-global-mode 1))
#+end_src

Aphelia formatting in YAML interrupts helm-style ={{ .Values }}=, so I turned it off
Can always turn it on again with =M-x apheleia-mode=
#+begin_src elisp
  (add-hook 'yaml-mode-hook #'(lambda () (apheleia-mode -1)))
#+end_src

JSON should have a =tab-width= of 2
#+begin_src elisp
    (add-hook 'js-json-mode-hook #'(lambda () (setq-local tab-width 2
                                                          indent-tabs-mode nil)))
#+end_src

* Org

Make a keymap for org
#+begin_src elisp
  (setq my/org-map (make-sparse-keymap))
  (define-key global-map (kbd "C-c o") `("org" . ,my/org-map))
#+end_src

Tags for quickly setting
#+begin_src elisp
  (setq org-tag-alist (append '((:startgroup . nil) ; at most one of the following
                              ("@home" . ?h)
                              ("@work" . ?w)
                              ("@out". ?o)
                              (:endgroup . nil)
                              ;; any of the following
                              ("project" . ?p)
                              ("learning" . ?l))
                            org-tag-alist-for-agenda))
#+end_src

My tags and their font faces
#+begin_src elisp
(setq my/org-todo-keywords '(
                             ("TODO(t)" . org-todo)
                             ("NEXT(n)" .  (:foreground "#34ebd8" :weight bold :slant italic))
                             ("PROG(p!)" . (:foreground "green" :weight bold))
                             ("HOLD(h@)" . (:background "orange" :foreground "white")) ; in progress but held up
                             ("|")
                             ("DONE(d!)" . org-done)
                             ("WONT(w@/!)" . (:foreground "red" :weight bold))))
#+end_src

#+begin_src elisp
  (use-package org
    :ensure t
    :config
    (setq org-agenda-files (list (expand-file-name "~/org")))
    ;; set faces
    (setq org-todo-keywords (list (append '(sequence)
                                        (seq-map #'(lambda (elt)
                                                     (if (listp elt)
                                                         (car elt)
                                                       elt))
                                                 my/org-todo-keywords))))

  (setq org-todo-keyword-faces (let ((f (lambda (elt)
                                         (if (listp elt)
                                             `(
                                              ,(seq-take-while #'(lambda (elt) (not (equal ?\( elt))) (car elt))
                                              .
                                              ,(cdr elt))
                                           elt)
                                         )))
                                 (seq-map #'(lambda (elt) (funcall f elt)) my/org-todo-keywords)))
  ;; 
    ;; config files
    (setq +org-chores-file (expand-file-name "~/org/chores.org"))
    (setq org-agenda-start-day nil
          org-agenda-span 1)
    :bind
    (:map my/org-map
          ("a" . org-agenda)
          ("c" . org-capture))
    :hook
    (org-mode . (lambda () (setq tab-width 8)))
    :init
    (add-hook 'org-mode-hook #'org-indent-mode))
#+end_src

A minor mode for presenting org (focusing)
#+begin_src elisp
    (use-package org-present
      :ensure t)
#+end_src

[[https://github.com/alphapapa/org-ql][org-ql]] makes searching org docs much easier
#+begin_src elisp
  (use-package org-ql
    :ensure t)
#+end_src

** org-jira
Reference: https://github.com/ahungry/org-jira?tab=readme-ov-file#installation
#+begin_src elisp
          (use-package org-jira
            :ensure t
            :custom
    	(jiralib-url "https://jupiterone.atlassian.net"))
#+end_src

#+RESULTS:


** Super agenda
#+begin_src elisp
  (use-package org-super-agenda
    :ensure t
    :init (org-super-agenda-mode 1))
#+end_src


Create the custom agenda command for super agenda
#+begin_src elisp
  (setq org-agenda-custom-commands
      '(("c" "Super agenda"
         ((agenda "" ((org-agenda-overriding-header "")
                      (org-super-agenda-groups
                       '((:log t)
                         (:name "Overdue"
                          :deadline past)
                         (:name "Habits"
                          :habit t)
                         (:name "Today"
                          :time-grid t
                          :date today)
                         (:name "Unstarted"
                          :scheduled past)
                         (:discard (:anything t))
                         ))))
          (alltodo "" ((org-agenda-overriding-header "")
                       (org-super-agenda-groups
                        `((:log t)
  			
                         (:name "Important"
                          :priority "A"
                          :face (:weight ultra-bold :background "blue")
                          :order 2)
                          (:name "Next"
                           :todo "NEXT"
                           :order 4)
                         (:name "Coming up"
                                :scheduled future
                                :order 5)
                          (:name "In progress"
                           :todo "PROG"
                           :order 3)
                          (:name "Can wait"
                           :priority "C"
                           :order 6)
                          (:name "If time"
                           :priority "B"
                           :order 5)
  			(:name "Jira -- other"
  			       :file-path ,(expand-file-name "~/.org-jira"))
                          (:name "Blocked"
                                 :todo "HOLD"
                                 :order 100)
                          (:discard (:file-path ,(expand-file-name "~/org/habits.org")))
                          (:discard (:anything t))))))))))
#+end_src

#+RESULTS:
| c | Super agenda | ((agenda  ((org-agenda-overriding-header ) (org-super-agenda-groups '((:log t) (:name Overdue :deadline past) (:name Habits :habit t) (:name Today :time-grid t :date today) (:name Unstarted :scheduled past) (:discard (:anything t)))))) (alltodo  ((org-agenda-overriding-header ) (org-super-agenda-groups `((:log t) (:name Important :priority A :face (:weight ultra-bold :background blue) :order 2) (:name Next :todo NEXT :order 4) (:name Coming up :scheduled future :order 5) (:name In progress :todo PROG :order 3) (:name Can wait :priority C :order 6) (:name If time :priority B :order 5) (:name Jira -- other :file-path ,(expand-file-name ~/.org-jira)) (:name Blocked :todo HOLD :order 100) (:discard (:file-path ,(expand-file-name ~/org/habits.org))) (:discard (:anything t))))))) |


** Templates
#+begin_src elisp
    (setq org-capture-templates '(("a" "Agenda")
                                ("at" "TODO" entry
                                 (file "~/org/agenda.org")
                                 "* TODO %?"
                                 :empty-lines-before 1)
                                  ("ad" "Deadline" entry
                                   (file+olp+datetree "~/org/agenda.org")
                                   "* %?\nDEADLINE: %^{at}t")
                                  ("t" "Todos")
                                  ("tt" "project todo" entry
                                   (file "~/org/projects.org")
                                   "* TODO %?\n%i"
                                 :empty-lines-before 1)
                                  ("tf" "file todo" entry
                                   (file "~/org/projects.org")
                                   "* TODO %?\n%a"
                               :empty-lines-before 1)
                                  ("tn" "today" entry
                                   (file+headline "~/org/todo.org" "Todos")
                                   "* TODO %?\n%t"
                                 :empty-lines-before 1)
                                  ("td" "deadline" entry
                                   (file+headline "~/org/todo.org" "Todos")
                                   "* TODO %?\nDEADLINE: %^{at}t"
                               :empty-lines-before 1)
                                  ("ts" "scheduled" entry
                                   (file+headline "~/org/todo.org" "Todos")
                                   "* TODO %?\nSCHEDULED: %^{at}t"
                                 :empty-lines-before 1)
                                  ("c" "chore" entry
                                   (file +org-chores-file)
                                   "* TODO %?\nDEADLINE: %t"
                               :empty-lines-before 1)
                                  ("n" "notes")
                                  ("nd" "discussion" entry
                                   (file+datetree "~/org/discussions.org")
                                   "* %?"
                                   :tree-type month)
    			      ("nf" "file note" entry
    			       (file "~/org/notes.org")
    			       "* %?\n%a"
  			       :empty-lines-after 1)
                                  ("d" "developer log" entry
                                   (file+datetree "~/org/dev_log.org")
                                   "* %?\n** Worked on\n\n** Went well\n\n** Room for improvement"
                                   :empty-lines-after 1)))

#+end_src

#+RESULTS:
| a  | Agenda   |       |                                      |           |                     |   |
| at | TODO     | entry | (file ~/org/agenda.org)              | * TODO %? | :empty-lines-before | 1 |
| ad | Deadline | entry | (file+olp+datetree ~/org/agenda.org) | * %?      |                     |   |


** Org brain
#+begin_src elisp
  (use-package org-brain
    :ensure t
    :bind
    (("C-c o b" . org-brain-visualize)))
#+end_src


* Fun
Nyan cat showing buffer position? Sure
#+begin_src elisp
  (use-package nyan-mode
    :ensure t
    :config
    ;; (setq nyan-animate-nyancat t
    ;;       nyan-bar-length 24)
    :init
    (when (display-graphic-p)
      (nyan-mode 1)))
#+end_src



* Helping
[[https://www.reddit.com/r/emacs/comments/1ewv1om/do_you_use_any_package_to_show_a_directory_tree/][This reddit post]]

#+begin_src elisp
  (defun treemacs-git-project ()
  (if-let ((root (project-root (project-current t)))
           (name (project-name (project-current t))))
      (progn
        (treemacs-do-add-project-to-workspace root name)
        (message (format "Added %s to treemacs" name)))
    (message "No project found")))

  ;; (add-hook 'treemacs-post-buffer-init-hook #'treemacs-git-project)
#+end_src
